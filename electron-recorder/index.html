<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>VA Call Recorder</title>
  <style>
    body { font-family: system-ui; margin: 30px; background: #1a1a1a; color: #fff; }
    h1 { font-size: 20px; margin-bottom: 20px; }
    .controls { display: flex; gap: 10px; margin-bottom: 20px; }
    button { padding: 12px 20px; font-size: 14px; cursor: pointer; border: none; border-radius: 6px; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #startBtn { background: #2d7d46; color: white; }
    #stopBtn { background: #b33; color: white; }
    .status { padding: 12px; background: #333; border-radius: 6px; margin-bottom: 15px; }
    .ok { color: #4f4; }
    .err { color: #f44; }
    .levels { display: flex; gap: 20px; margin-bottom: 20px; }
    .level { flex: 1; }
    .level label { display: block; margin-bottom: 5px; font-size: 13px; }
    input[type="range"] { width: 100%; }
    #download { display: none; padding: 12px 20px; background: #36c; color: white; text-decoration: none; border-radius: 6px; }
  </style>
</head>
<body>
  <h1>VA Call Recorder (Mic + System Audio)</h1>
  
  <div class="status" id="status">Status: Ready</div>
  
  <div class="controls">
    <button id="startBtn">Start Recording</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="download">Save Recording...</button>
  </div>

  <div class="levels">
    <div class="level">
      <label>System Audio Level: <span id="sysVal">1.00</span></label>
      <input type="range" id="sysGain" min="0" max="2" step="0.01" value="1">
    </div>
    <div class="level">
      <label>Mic Level: <span id="micVal">1.00</span></label>
      <input type="range" id="micGain" min="0" max="2" step="0.01" value="1">
    </div>
  </div>

  <p style="font-size: 12px; opacity: 0.7;">
    This captures ALL system audio (including VA Video Connect) plus your mic.<br>
    Use headphones to avoid echo.
  </p>

<script>
const { getLoopbackAudioMediaStream } = require('electron-audio-loopback');
const { ipcRenderer } = require('electron');

let audioContext, destination, sysGainNode, micGainNode;
let recorder, chunks = [];
let systemStream, micStream;
let lastBlob = null;

const status = document.getElementById('status');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const download = document.getElementById('download');
const sysGain = document.getElementById('sysGain');
const micGain = document.getElementById('micGain');
const sysVal = document.getElementById('sysVal');
const micVal = document.getElementById('micVal');

function setStatus(msg, ok) {
  status.textContent = 'Status: ' + msg;
  status.className = 'status' + (ok === true ? ' ok' : ok === false ? ' err' : '');
}

sysGain.oninput = () => {
  sysVal.textContent = Number(sysGain.value).toFixed(2);
  if (sysGainNode) sysGainNode.gain.value = sysGain.value;
};

micGain.oninput = () => {
  micVal.textContent = Number(micGain.value).toFixed(2);
  if (micGainNode) micGainNode.gain.value = micGain.value;
};

startBtn.onclick = async () => {
  try {
    download.style.display = 'none';
    setStatus('Getting system audio...');
    
    // Get system audio via electron-audio-loopback
    systemStream = await getLoopbackAudioMediaStream();
    
    setStatus('Getting microphone...');
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
    });

    // Set up audio mixing
    audioContext = new AudioContext();
    destination = audioContext.createMediaStreamDestination();

    sysGainNode = audioContext.createGain();
    micGainNode = audioContext.createGain();
    sysGainNode.gain.value = sysGain.value;
    micGainNode.gain.value = micGain.value;

    const sysSource = audioContext.createMediaStreamSource(systemStream);
    const micSource = audioContext.createMediaStreamSource(micStream);

    sysSource.connect(sysGainNode).connect(destination);
    micSource.connect(micGainNode).connect(destination);

    // Record mixed stream
    chunks = [];
    recorder = new MediaRecorder(destination.stream, { mimeType: 'audio/webm;codecs=opus' });
    
    recorder.ondataavailable = e => {
      if (e.data.size > 0) chunks.push(e.data);
    };

    recorder.onstop = () => {
      lastBlob = new Blob(chunks, { type: 'audio/webm' });
      download.style.display = 'inline-block';
      download.textContent = 'Save Recording...';
      setStatus('Recording ready - click Save', true);
    };

    recorder.start(1000);
    setStatus('Recording...', true);
    startBtn.disabled = true;
    stopBtn.disabled = false;

  } catch (err) {
    setStatus('Error: ' + err.message, false);
    console.error(err);
  }
};

stopBtn.onclick = () => {
  if (recorder && recorder.state === 'recording') {
    recorder.stop();
  }
  if (systemStream) systemStream.getTracks().forEach(t => t.stop());
  if (micStream) micStream.getTracks().forEach(t => t.stop());
  startBtn.disabled = false;
  stopBtn.disabled = true;
};

download.onclick = async () => {
  if (!lastBlob) return;
  const stamp = new Date().toISOString().replace(/:/g, '-');
  const defaultName = `va-call-${stamp}.webm`;
  const arrayBuffer = await lastBlob.arrayBuffer();
  const saved = await ipcRenderer.invoke('save-recording', arrayBuffer, defaultName);
  if (saved) {
    setStatus('Saved to: ' + saved, true);
  }
};

// API handlers from main process
ipcRenderer.on('api-get-status', () => {
  const isRecording = recorder && recorder.state === 'recording';
  const hasRecording = !!lastBlob;
  ipcRenderer.send('api-status-response', { isRecording, hasRecording });
});

ipcRenderer.on('api-start', () => {
  if (!startBtn.disabled) startBtn.click();
});

ipcRenderer.on('api-stop', () => {
  if (!stopBtn.disabled) stopBtn.click();
});

ipcRenderer.on('api-save', async (event, savePath) => {
  if (!lastBlob) {
    ipcRenderer.send('api-save-response', { ok: false, error: 'No recording' });
    return;
  }
  try {
    const arrayBuffer = await lastBlob.arrayBuffer();
    const fs = require('fs');
    fs.writeFileSync(savePath, Buffer.from(arrayBuffer));
    ipcRenderer.send('api-save-response', { ok: true, path: savePath });
  } catch (e) {
    ipcRenderer.send('api-save-response', { ok: false, error: e.message });
  }
});
</script>
</body>
</html>
